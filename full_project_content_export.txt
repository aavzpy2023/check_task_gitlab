--- Contenido del Proyecto Exportado el 2025-11-19 11:37:31 ---


// --- ./.env ---

# .env
GITLAB_URL=https://gitlab.azcuba.cu
GITLAB_TOKEN=gg9sdUFoL757JyMbM_hw
POSTGRES_HOST=postgres_chatbot
POSTGRES_PORT=5430
POSTGRES_DB=chatbot
POSTGRES_USER=admin
POSTGRES_PASSWORD=postgres

// --- ./.prettierrc.json ---

{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}

// --- ./README.md ---

# GitLab Review Task Dashboard

![Python](https://img.shields.io/badge/Python-3.11-blue.svg) ![FastAPI](https://img.shields.io/badge/FastAPI-0.103-green.svg) ![Streamlit](https://img.shields.io/badge/Streamlit-1.33-ff4b4b.svg) ![Docker](https://img.shields.io/badge/Docker-Compose-blue.svg)

![Dashboard Screenshot](URL_TO_YOUR_SCREENSHOT.png)

A full-stack dashboard I designed and built to solve a real-world business problem: monitoring GitLab issues marked for review across a large portfolio of projects. As a QA Lead overseeing 40+ active projects, I engineered this tool to automate a tedious manual process, providing a centralized, real-time view of all pending review tasks.

The application is built with a modern, decoupled frontend/backend architecture and is fully containerized with Docker for development and production environments.

## The Problem It Solves

In a large development environment, manually tracking issues that require QA review across dozens of GitLab projects is time-consuming, inefficient, and prone to human error. This workflow creates bottlenecks, delays feedback to developers and testers, and makes it difficult for leads to get a high-level overview of the team's workload. This dashboard automates the entire process, providing an "at-a-glance" status of all tasks pending review.

## Architecture & Technology Stack

The system is architected as two distinct services communicating via an internal API, orchestrated by Docker Compose.

* **Backend (FastAPI):**
  * A robust API service written in Python using **FastAPI**.
  * Periodically fetches issue data from the **GitLab API** for multiple projects.
  * Handles errors gracefully (e.g., network timeouts, invalid project IDs) to ensure the service remains stable.
  * Reads project configurations from an external `projects.csv` file for easy management without code changes.
  * **Technologies:** `FastAPI`, `uvicorn`, `requests`.

* **Frontend (Streamlit):**
  * A dynamic and interactive web interface built with **Streamlit**.
  * Consumes the FastAPI backend to get real-time project and task data.
  * Features a responsive two-column layout with a sticky navigation menu for active projects, prioritized by task count.
  * Uses **Pandas** for data manipulation and presentation.
  * **Technologies:** `Streamlit`, `requests`, `pandas`.

* **DevOps:**
  * **Docker & Docker Compose:** The entire application is containerized with a multi-stage `Dockerfile.backend` and `Dockerfile.frontend`.
  * Docker compose file for local development (`docker-compose.yml`).

---

## Project Status & Roadmap

The dashboard is currently fully functional for its core purpose of monitoring and displaying tasks.

### Future Roadmap

* **[ ] LLM Integration for Summarization:** Integrate a Large Language Model (LLM) to provide natural language summaries of pending tasks (e.g., "There are 5 critical tasks for Project Alpha, mostly assigned to John Doe"). The initial proof-of-concept for context acquisition and formatting (`script.py`) is included in this repository.

* **[ ] Historical Analytics:** Add a database (e.g., SQLite or PostgreSQL) to store historical task data, allowing for trend analysis (e.g., average time in review per project).
* **[ ] User Authentication:** Implement a login system to personalize the dashboard and restrict access.

---

## Getting Started

### Prerequisites

* Docker & Docker Compose
* A GitLab instance and a Personal Access Token with `api` scope.

### Setup & Launch

1. **Clone the repository:**

    ```bash
    git clone [YOUR-REPOSITORY-URL]
    cd check_task_gitlab
    ```

2. **Configure Environment:**
    Create a `.env` file from the provided template:

    ```bash
    cp .env.example .env
    ```

    Then, edit the `.env` file and add your GitLab URL and token.

3. **Configure Projects:**
    Create a `projects.csv` file inside /backend directory from the template:

    ```bash
    cp projects.csv.example projects.csv
    ```

    Then, edit `projects.csv` to include the IDs and names of the projects you want to monitor.

4. **Build and Launch:**
    Use the development compose file to build and run the services:

    ```bash
    docker-compose up --build -d
    ```

5. **Access the Dashboard:**
    Open your browser and navigate to `http://localhost:8501`.

## License

This project is licensed under the MIT License. See the `LICENSE` file for details.


// --- ./backend/.devcontainer/devcontainer.json ---

{
    "name": "App python",
    "image": "python:3.11",  // o tu imagen personalizada
    
    // INSTALA HERRAMIENTAS ESENCIALES
    "features": {
        "ghcr.io/devcontainers/features/python:1": {
            "version": "3.9"
        }
    },
    
    // CONFIGURACIONES DE VS CODE DENTRO DEL CONTENEDOR
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-python.python",
                "ms-python.vscode-pylance",
//                "batisteo.vscode-django"
            ],
            "settings": {
                "python.defaultInterpreterPath": "/usr/local/bin/python",
                "python.analysis.extraPaths": ["/workspace"],
  //              "python.analysis.django": true
            }
        }
    },
    
    // COMANDOS QUE SE EJECUTAN AL CREAR EL CONTENEDOR
    // "postCreateCommand": "pip install -r requirements.txt && python manage.py migrate",
    
    // MONTA TU C√ìDIGO
    "mounts": [
        "source=${localWorkspaceFolder},target=/workspace,type=bind"
    ],
    
    "workspaceFolder": "/workspace"
}

// --- ./backend/.env ---

SYNC_INTERVAL_SECONDS=1800

// --- ./backend/.vscode/settings.json ---

{
    "python.defaultInterpreterPath": "/usr/local/bin/python",
    "python.analysis.autoImportCompletions": true,
    "python.analysis.completeFunctionParens": true,
    "python.analysis.typeCheckingMode": "basic",
    "python.analysis.extraPaths": [
        "./",
        "./app"
    ],
    "python.languageServer": "Pylance",
    
    // üî• NUEVAS CONFIGURACIONES PARA FILTRAR SUGERENCIAS GEN√âRICAS
    "editor.suggest.showSnippets": false,
    "editor.suggest.showWords": false,
    "editor.wordBasedSuggestions": "off",
    
    "editor.quickSuggestions": {
        "other": true,
        "comments": false,
        "strings": true
    },
    
    // Opcional: Mejorar el ordenamiento
    "editor.suggestSelection": "recentlyUsed",
    "editor.suggest.snippetsPreventQuickSuggestions": false
}

// --- ./backend/Dockerfile ---

# /backend/Dockerfile
FROM python:3.11-slim-bookworm

WORKDIR /app

# SSS: Instalar la dependencia de sistema 'pandoc' requerida por 'pypandoc'.
# Esto es esencial para la generaci√≥n de PDFs.
RUN apt-get update && apt-get install -y pandoc && rm -rf /var/lib/apt/lists/*

# Copy and install dependencies first to leverage Docker layer caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application code
COPY projects.csv .

# Expose the port the application will run on
EXPOSE 8001

# The command to run the FastAPI application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8001"]

// --- ./backend/label_discovery.py ---

import os
import sys
from collections import defaultdict
from pprint import pprint


import pandas as pd
import requests
import urllib3

# --- SSS: Copia de la infraestructura necesaria de main.py ---
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Cargar variables de entorno (asume que se ejecuta en el mismo entorno que la app)
from dotenv import load_dotenv

load_dotenv()

GITLAB_URL = os.getenv("GITLAB_URL")
PRIVATE_TOKEN = os.getenv("GITLAB_TOKEN")
PROJECTS_CSV_PATH = "./projects.csv"


def gitlab_api_request(method: str, endpoint: str, **kwargs) -> requests.Response:
    if not PRIVATE_TOKEN:
        raise ValueError("GitLab token no configurado.")
    headers = {"PRIVATE-TOKEN": PRIVATE_TOKEN}
    api_url = f"{GITLAB_URL}/api/v4/{endpoint}"
    try:
        response = requests.request(
            method, api_url, headers=headers, verify=False, timeout=15, **kwargs
        )
        response.raise_for_status()
        return response
    except requests.exceptions.RequestException as e:
        print(
            f"ERROR: Fallo en la petici√≥n a GitLab API ({api_url}): {e}",
            file=sys.stderr,
        )
        return None

def discover_labels():
    """
    Audita todos los proyectos monitoreados, descubre variaciones de etiquetas
    y genera un diccionario de mapeo para la aplicaci√≥n principal.
    """
    print("--- [AUDITOR√çA DE ETIQUETAS] Iniciando escaneo... ---")

    # Palabras clave para identificar cada categor√≠a (en min√∫sculas)
    KEYWORDS = {
        "FUNCTIONAL_REVIEW": ["funcional"],
        "QA_REVIEW": ["revisi√≥n", "revision"],
        "IN_PROGRESS": ["ejecucion", "ejecuci√≥n"],
    }

    if not os.path.exists(PROJECTS_CSV_PATH):
        print(
            f"FATAL: No se encontr√≥ el archivo '{PROJECTS_CSV_PATH}'.", file=sys.stderr
        )
        return

    try:
        projects_df = pd.read_csv(PROJECTS_CSV_PATH)
        project_ids = projects_df["project_id"].tolist()
    except Exception as e:
        print(f"FATAL: Error al leer '{PROJECTS_CSV_PATH}': {e}", file=sys.stderr)
        return

    print(f"Se auditar√°n {len(project_ids)} proyectos.")

    discovered_labels = defaultdict(set)

    for project_id in project_ids:
        print(f"  -> Escaneando Proyecto ID: {project_id}...")
        response = gitlab_api_request(
            "get", f"projects/{project_id}/labels?per_page=100"
        )
        if not response:
            continue

        project_labels = response.json()
        for label in project_labels:
            name_lower = label["name"].lower()

            # La l√≥gica debe ir de lo m√°s espec√≠fico a lo m√°s general
            if any(keyword in name_lower for keyword in KEYWORDS["FUNCTIONAL_REVIEW"]):
                discovered_labels["FUNCTIONAL_REVIEW"].add(label["name"])
            elif any(keyword in name_lower for keyword in KEYWORDS["QA_REVIEW"]):
                discovered_labels["QA_REVIEW"].add(label["name"])
            elif any(keyword in name_lower for keyword in KEYWORDS["IN_PROGRESS"]):
                discovered_labels["IN_PROGRESS"].add(label["name"])

    print("\n--- [AUDITOR√çA COMPLETA] Descubrimiento finalizado. ---")
    if not discovered_labels:
        print("No se encontraron etiquetas que coincidan con las palabras clave.")
        return

    # Generar el diccionario de Python final
    final_mapping = {
        "TaskStatus.IN_PROGRESS": sorted(list(discovered_labels["IN_PROGRESS"])),
        "TaskStatus.QA_REVIEW": sorted(list(discovered_labels["QA_REVIEW"])),
        "TaskStatus.FUNCTIONAL_REVIEW": sorted(
            list(discovered_labels["FUNCTIONAL_REVIEW"])
        ),
    }

    print(
        "\nCOPIE Y PEGUE EL SIGUIENTE BLOQUE EN 'backend/main.py' REEMPLAZANDO 'LABEL_MAPPING':\n"
    )
    print("LABEL_MAPPING = {")
    for key, labels in final_mapping.items():
        print(f"    {key}: {labels},")
    print("}")
    print("\n--- [FIN DEL SCRIPT] ---")


if __name__ == "__main__":
    discover_labels()


// --- ./backend/main.py ---

import enum
import os
import sys
import tempfile
import time
from contextlib import asynccontextmanager
from threading import Thread
from typing import Any, Dict, List, Optional
from collections import defaultdict

import pandas as pd
import pypandoc
import requests
import urllib3
from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, Query
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field
from sqlalchemy import (
    BigInteger,
    Column,
    DateTime,
    ForeignKey,
    String,
    create_engine,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.dialects.postgresql import insert as pg_insert
from sqlalchemy.orm import Session, declarative_base, sessionmaker

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- Configuraci√≥n ---
GITLAB_URL = os.getenv("GITLAB_URL")
PRIVATE_TOKEN = os.getenv("GITLAB_TOKEN")
DATABASE_URL = f"postgresql://{os.getenv('POSTGRES_USER')}:{os.getenv('POSTGRES_PASSWORD')}@postgres_chatbot:5432/{os.getenv('POSTGRES_DB')}"
SYNC_INTERVAL_SECONDS = int(os.getenv("SYNC_INTERVAL_SECONDS", 600))
PROJECTS_CSV_PATH = "./projects.csv"
SYNC_IN_PROGRESS = False

# --- SQLAlchemy Setup ---
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- Modelos ---
class TaskStatus(str, enum.Enum):
    IN_PROGRESS = "En Ejecucion"
    QA_REVIEW = "PARA REVISI√ìN"
    FUNCTIONAL_REVIEW = "Revision Funcional"

LABEL_MAPPING = {
    TaskStatus.IN_PROGRESS: ['A EJECUCI√ìN', 'A ejecuci√≥n', 'EN EJECUCI√ìN', 'Ejecuci√≥n', 'En Ejecuci√≥n'],
    TaskStatus.QA_REVIEW: ['PARA REVISION', 'PARA REVISI√ìN', 'Para Revisi√≥n'],
    TaskStatus.FUNCTIONAL_REVIEW: ['REVISION FUNCIONAL', 'REVISI√ìN FUNCIONAL', 'Revisi√≥n Funcional'],
}

class SystemMetadata(Base):
    __tablename__ = "system_metadata"
    key = Column(String(50), primary_key=True, default="singleton")
    last_sync_time = Column(DateTime(timezone=True), server_default=func.now())

class MonitoredProject(Base):
    __tablename__ = "monitored_projects"
    project_id = Column(BigInteger, primary_key=True, index=True)
    project_name = Column(String(255), nullable=False)

class GitLabTaskDB(Base):
    __tablename__ = "gitlab_tasks"
    task_id = Column(BigInteger, primary_key=True)
    project_id = Column(BigInteger, ForeignKey("monitored_projects.project_id"), nullable=False, index=True)
    task_status_label = Column(String(50), nullable=False, index=True)
    updated_at = Column(DateTime(timezone=True))
    raw_data = Column(JSONB)

class TimeStats(BaseModel):
    human_time_estimate: Optional[str] = None
    human_total_time_spent: Optional[str] = None

class Task(BaseModel):
    project_id: int
    title: str
    description: Optional[str] = None
    author: str
    url: str
    assignee: Optional[str] = None
    milestone: Optional[str] = None
    created_at: Optional[str] = None
    labels: List[str] = []
    time_stats: TimeStats = Field(default_factory=TimeStats)

class TaskWithProject(Task):
    project_name: str

class ProjectSummary(BaseModel):
    id: int
    name: str
    review_task_count: int

# --- L√≥gica de Sincronizaci√≥n ---
def sync_single_project(project_id: int, db: Session):
    try:
        db.query(GitLabTaskDB).filter(GitLabTaskDB.project_id == project_id).delete(synchronize_session=False)
        tasks_found = defaultdict(list)
        for status_enum, label_variations in LABEL_MAPPING.items():
            for label in label_variations:
                print(f"--- [SYNC] Proyecto {project_id}: Consultando etiqueta '{label}'...")
                try:
                    tasks_json = gitlab_api_request("get", f"projects/{project_id}/issues?labels={label}&state=opened&per_page=100").json()
                    if tasks_json:
                        for task in tasks_json:
                            tasks_found[task['id']].append({"status": status_enum, "data": task})
                except Exception: continue
        tasks_to_insert = []
        for task_id, found_states in tasks_found.items():
            chosen_state = None
            if any(s['status'] == TaskStatus.FUNCTIONAL_REVIEW for s in found_states): chosen_state = TaskStatus.FUNCTIONAL_REVIEW
            elif any(s['status'] == TaskStatus.QA_REVIEW for s in found_states): chosen_state = TaskStatus.QA_REVIEW
            elif any(s['status'] == TaskStatus.IN_PROGRESS for s in found_states): chosen_state = TaskStatus.IN_PROGRESS
            if chosen_state:
                final_task_data = next(s['data'] for s in found_states if s['status'] == chosen_state)
                tasks_to_insert.append({"task_id": task_id, "project_id": final_task_data["project_id"], "task_status_label": chosen_state.value, "updated_at": final_task_data["updated_at"], "raw_data": final_task_data})
        if tasks_to_insert:
            db.execute(pg_insert(GitLabTaskDB).values(tasks_to_insert))
        db.commit()
        print(f"--- [SYNC] ‚úÖ Proyecto {project_id}: Sincronizaci√≥n exitosa. {len(tasks_to_insert)} tareas √∫nicas procesadas.")
    except Exception as e:
        print(f"--- [SYNC] üö® FALLO para proyecto {project_id}: {e}")
        db.rollback()

def run_full_sync(db: Session):
    global SYNC_IN_PROGRESS
    if SYNC_IN_PROGRESS:
        print("--- [SYNC] Advertencia: Se intent√≥ iniciar una sincronizaci√≥n mientras otra ya estaba en curso.")
        return
    
    try:
        SYNC_IN_PROGRESS = True
        print(f"--- [SYNC] Iniciando ciclo... ---")
        projects = db.query(MonitoredProject).all()
        if not projects:
            print("--- [SYNC] No hay proyectos para sincronizar.")
            return
        
        for project in projects:
            sync_single_project(project.project_id, db)
        
        stmt = pg_insert(SystemMetadata).values(key="singleton", last_sync_time=func.now()).on_conflict_do_update(index_elements=['key'], set_={'last_sync_time': func.now()})
        db.execute(stmt)
        db.commit()
        print(f"--- [SYNC] ‚úÖ Ciclo completado. Hora actualizada. ---")
    finally:
        SYNC_IN_PROGRESS = False
        print(f"--- [SYNC] Finalizando ciclo. Lock liberado. ---")

def sync_all_projects_periodically(interval_seconds: int):
    while True:
        db = SessionLocal()
        try:
            run_full_sync(db)
        except Exception as e:
            print(f"--- [SYNC THREAD] üö® ERROR CR√çTICO durante el ciclo: {e}")
        finally:
            db.close()
        print(f"--- [SYNC THREAD] Esperando {interval_seconds} segundos. ---")
        time.sleep(interval_seconds)

def gitlab_api_request(method: str, endpoint: str, raise_for_status: bool = True, **kwargs) -> requests.Response:
    if not PRIVATE_TOKEN:
        raise HTTPException(status_code=500, detail="GitLab token no configurado.")
    headers = {"PRIVATE-TOKEN": PRIVATE_TOKEN}
    api_url = f"{GITLAB_URL}/api/v4/{endpoint}"
    try:
        response = requests.request(method, api_url, headers=headers, verify=False, timeout=10, **kwargs)
        if raise_for_status:
            response.raise_for_status()
        return response
    except requests.exceptions.HTTPError as e:
        raise HTTPException(status_code=e.response.status_code, detail=f"Error de GitLab API: {e.response.text}")
    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=502, detail=f"Error de red: {e}")

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("--- [STARTUP] Iniciando ciclo de vida de la aplicaci√≥n... ---")
    db = SessionLocal()
    try:
        print("--- [STARTUP] Verificando y creando esquema de base de datos...")
        Base.metadata.create_all(bind=engine)
        print("--- [STARTUP] ‚úÖ Esquema de BD verificado.")
        if db.query(MonitoredProject).count() == 0:
            print("--- [STARTUP] ‚ÑπÔ∏è La tabla de proyectos est√° vac√≠a. Intentando auto-poblar desde 'projects.csv'...")
            if not os.path.exists(PROJECTS_CSV_PATH):
                print(f"--- [STARTUP] ‚ö†Ô∏è ADVERTENCIA: No se encontr√≥ '{PROJECTS_CSV_PATH}'.")
            else:
                try:
                    df = pd.read_csv(PROJECTS_CSV_PATH)
                    projects_to_add = [MonitoredProject(project_id=int(row.project_id), project_name=str(row.project_name).strip()) for row in df.itertuples(index=False)]
                    db.add_all(projects_to_add)
                    db.commit()
                    print(f"--- [STARTUP] ‚úÖ Se poblaron {len(projects_to_add)} proyectos desde el CSV usando Pandas.")
                except Exception as e:
                    print(f"--- [STARTUP] üö® ERROR al leer o procesar CSV con Pandas: {e}")
                    db.rollback()
        else:
            print("--- [STARTUP] ‚ÑπÔ∏è La base de datos ya contiene proyectos. Saltando la fase de poblaci√≥n.")
        sync_thread = Thread(target=sync_all_projects_periodically, args=(SYNC_INTERVAL_SECONDS,), daemon=True)
        sync_thread.start()
        print("--- [STARTUP] ‚úÖ Hilo de sincronizaci√≥n iniciado.")
    except Exception as e:
        print(f"üö® FATAL durante el arranque: {e}")
        db.rollback()
    finally:
        db.close()
    yield
    print("--- [SHUTDOWN] La aplicaci√≥n se est√° apagando. ---")

app = FastAPI(title="Portal API v6.2", version="6.2.0", lifespan=lifespan, root_path="/api")

@app.post("/sync/all", status_code=202, tags=["Database Sync"])
def force_full_sync(background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    background_tasks.add_task(run_full_sync, db)
    return {"message": "La sincronizaci√≥n completa ha sido iniciada en segundo plano."}

@app.get("/sync/last_time", response_model=Dict[str, Optional[str]], tags=["Database Sync"])
def get_last_sync_time(db: Session = Depends(get_db)):
    metadata = db.query(SystemMetadata).filter(SystemMetadata.key == "singleton").first()
    if metadata and metadata.last_sync_time:
        return {"last_sync_time": metadata.last_sync_time.isoformat()}
    return {"last_sync_time": None}

@app.get("/projects/active_from_db", response_model=List[ProjectSummary], tags=["Task Dashboard (DB)"])
def get_active_projects_from_db(label: TaskStatus = Query(...), db: Session = Depends(get_db)):
    label_value = label.value
    results = (db.query(MonitoredProject.project_id, MonitoredProject.project_name, func.count(GitLabTaskDB.task_id).label("task_count")).join(GitLabTaskDB, MonitoredProject.project_id == GitLabTaskDB.project_id).filter(GitLabTaskDB.task_status_label == label_value).group_by(MonitoredProject.project_id, MonitoredProject.project_name).order_by(func.count(GitLabTaskDB.task_id).desc()).all())
    return [ProjectSummary(id=pid, name=pname, review_task_count=count) for pid, pname, count in results]

@app.get("/tasks/all_by_label", response_model=List[TaskWithProject], tags=["Task Dashboard (DB)"])
def get_all_tasks_by_label(label: TaskStatus = Query(...), db: Session = Depends(get_db)):
    label_value = label.value
    db_tasks = (db.query(GitLabTaskDB, MonitoredProject.project_name).join(MonitoredProject, GitLabTaskDB.project_id == MonitoredProject.project_id).filter(GitLabTaskDB.task_status_label == label_value).order_by(MonitoredProject.project_name, GitLabTaskDB.updated_at.desc()).all())
    if not db_tasks: return []
    task_list = []
    for db_task, project_name in db_tasks:
        issue = db_task.raw_data
        assignee = issue.get("assignees", [{}])[0].get("name") if issue.get("assignees") else None
        milestone = issue.get("milestone", {}).get("title") if issue.get("milestone") else None
        raw_time_stats = issue.get("time_stats", {}) or {}
        time_stats_obj = TimeStats(human_time_estimate=raw_time_stats.get("human_time_estimate"), human_total_time_spent=raw_time_stats.get("human_total_time_spent"))
        task_list.append(TaskWithProject(project_id=issue.get("project_id"), title=issue.get("title", "N/A"), description=issue.get("description"), author=issue.get("author", {}).get("name", "N/A"), url=issue.get("web_url", "#"), assignee=assignee, milestone=milestone, project_name=project_name, created_at=issue.get("created_at"), labels=issue.get("labels", []), time_stats=time_stats_obj))
    return task_list


@app.get("/projects/{project_id}/tasks_from_db", response_model=List[Task], tags=["Task Dashboard (DB)"])
def get_project_tasks_from_db(project_id: int, label: TaskStatus = Query(...), db: Session = Depends(get_db)):
    label_value = label.value
    db_tasks = db.query(GitLabTaskDB).filter(GitLabTaskDB.project_id == project_id, GitLabTaskDB.task_status_label == label_value).all()
    if not db_tasks: return []
    task_list = []
    for db_task in db_tasks:
        issue = db_task.raw_data
        assignee = issue["assignees"][0].get("name") if issue.get("assignees") else None
        milestone = issue["milestone"].get("title") if issue.get("milestone") else None
        task_list.append(Task(title=issue.get("title", "N/A"), description=issue.get("description"), author=issue.get("author", {}).get("name", "N/A"), url=issue.get("web_url", "#"), assignee=assignee, milestone=milestone))
    return task_list



# === Endpoints de Sincronizaci√≥n y Gesti√≥n ===


@app.post("/sync/project/{project_id}", status_code=200, tags=["Database Sync"])
def sync_project_tasks(project_id: int, db: Session = Depends(get_db)):
    try:
        tasks = gitlab_api_request(
            "get",
            f"projects/{project_id}/issues?labels={LABEL_TO_TRACK}&state=opened&per_page=100",
        ).json()
    except HTTPException as e:
        print(
            f"ADVERTENCIA: No se pudo obtener tareas para el proyecto {project_id}. Raz√≥n: {e.detail}"
        )
        db.query(GitLabTaskDB).filter(GitLabTaskDB.project_id == project_id).delete(
            synchronize_session=False
        )
        db.commit()
        return {
            "message": f"No se pudieron obtener tareas para el proyecto {project_id}. Limpiando de la BD."
        }
    db.query(GitLabTaskDB).filter(GitLabTaskDB.project_id == project_id).delete(
        synchronize_session=False
    )
    if not tasks:
        db.commit()
        return {
            "message": "No se encontraron tareas en revisi√≥n. La base de datos ha sido actualizada."
        }
    tasks_to_insert = [
        {
            "task_id": t["id"],
            "project_id": t["project_id"],
            "updated_at": t["updated_at"],
            "raw_data": t,
        }
        for t in tasks
    ]
    if tasks_to_insert:
        db.execute(pg_insert(GitLabTaskDB).values(tasks_to_insert))
    db.commit()
    return {
        "message": f"Sincronizaci√≥n exitosa. {len(tasks_to_insert)} tareas procesadas."
    }


@app.get("/monitored_projects", tags=["Project Management"])
def get_monitored_projects(db: Session = Depends(get_db)):
    return db.query(MonitoredProject).order_by(MonitoredProject.project_name).all()


@app.post("/monitored_projects", status_code=201, tags=["Project Management"])
def add_monitored_project(project_id: int, project_name: str, db: Session = Depends(get_db)):
    existing_project = (
        db.query(MonitoredProject)
        .filter(MonitoredProject.project_id == project_id)
        .first()
    )
    if existing_project:
        raise HTTPException(
            status_code=409, detail="El proyecto ya est√° siendo monitoreado."
        )
    new_project = MonitoredProject(project_id=project_id, project_name=project_name)
    db.add(new_project)
    db.commit()
    db.refresh(new_project)
    return new_project


# === Endpoints de Sincronizaci√≥n con Gesti√≥n de Estado ===
@app.get("/sync/status", response_model=Dict[str, bool], tags=["Database Sync"])
def get_sync_status():
    """Consulta si un proceso de sincronizaci√≥n est√° actualmente en curso."""
    return {"is_syncing": SYNC_IN_PROGRESS}

@app.post("/sync/all", status_code=202, tags=["Database Sync"])
def force_full_sync(background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    """Inicia una sincronizaci√≥n completa si no hay otra en curso."""
    if SYNC_IN_PROGRESS:
        raise HTTPException(status_code=409, detail="Una sincronizaci√≥n ya est√° en progreso.")
    
    background_tasks.add_task(run_full_sync, db)
    return {"message": "La sincronizaci√≥n completa ha sido iniciada en segundo plano."}

// --- ./backend/requirements.txt ---

fastapi
uvicorn[standard]
requests
python-dotenv
SQLAlchemy
aiosqlite
pypandoc

// --- ./docker-compose-gh.yml ---

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: gitlab_dashboard_backend
    volumes:
      - ./backend:/app
    env_file:
      - .env
    expose:
      - "8001" # No se mapea al host, solo se expone a la red interna
    networks:
      - app-network
    depends_on:
      postgres_chatbot:
        condition: service_healthy
    restart: unless-stopped

  frontend-react:
    build:
      context: ./frontend-react
      dockerfile: Dockerfile
    container_name: gitlab_dashboard_frontend_react
    ports:
      - "8503:80"
    depends_on:
      - backend
    networks:
      - app-network
    restart: unless-stopped
    
  postgres_chatbot:
    image: postgres:16
    container_name: postgres_chatbot
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "${POSTGRES_PORT}:5432"
    # SSS: Aseguramos que la base de datos se una expl√≠citamente a la red
    networks:
      - app-network
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

# SSS: Definici√≥n expl√≠cita de la red compartida
networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:

// --- ./docker-compose-prod.yml ---

# docker-compose.yml
# SSS v4.2.0 - Configuraci√≥n de Producci√≥n Base

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: gitlab_dashboard_backend
    env_file:
      - .env
    networks:
      - app-network
    depends_on:
      postgres_chatbot:
        condition: service_healthy
    restart: unless-stopped

  frontend-react:
    build:
      context: ./frontend-react
      dockerfile: Dockerfile # Usa el Dockerfile de producci√≥n por defecto
    container_name: gitlab_dashboard_frontend_react
    ports:
      - "8503:80"
    networks:
      - app-network
    depends_on:
      - backend
    restart: unless-stopped
    
  postgres_chatbot:
    image: postgres:16
    container_name: postgres_chatbot
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "${POSTGRES_PORT}:5432"
    networks:
      - app-network
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:

// --- ./docker-compose.yml ---

services:
  nginx:
    # build:
    #   context: ./nginx
    image: nginx:latest
    container_name: main_proxy
    ports:
      - "8503:80"
    networks:
      - app-network
    depends_on:
      - backend
      - frontend-react
    restart: unless-stopped
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf

  backend:
    build:
      context: ./backend
    container_name: gitlab_dashboard_backend
    volumes:
      - ./backend:/app
    env_file:
      - .env
    networks:
      - app-network
    depends_on:
      postgres_chatbot:
        condition: service_healthy
    restart: unless-stopped

  frontend-react:
    # build:
    #   context: ./frontend-react
    image: gitlab-dashboard-frontend:victory-final
    container_name: gitlab_dashboard_frontend_react
    volumes:
      - ./frontend-react:/app
      - /app/node_modules
    networks:
      - app-network
    restart: unless-stopped
    
  postgres_chatbot:
    image: postgres:16
    container_name: postgres_chatbot
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "${POSTGRES_PORT}:5432"
    networks:
      - app-network
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # - ./postgres/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

# SSS: Definici√≥n expl√≠cita de la red compartida
networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:

// --- ./frontend-react/Dockerfile ---

FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

# Exponer el puerto de Vite a la red interna de Docker
EXPOSE 3000

# SSS: Correcci√≥n Definitiva - Usamos 'npm run dev' que sabe c√≥mo encontrar
# y ejecutar el binario de Vite desde node_modules.
CMD ["npm", "run", "dev"]

// --- ./frontend-react/dist/index.html ---



// --- ./frontend-react/entrypoint.sh ---

#!/bin/sh
# SSS v4.2.0 - Entrypoint para el Contenedor de Desarrollo Frontend

# Salir inmediatamente si un comando falla
set -e

echo "--- SSS: Iniciando contenedor de desarrollo frontend ---"

# 1. Ejecutar el build inicial de Vite para crear la carpeta /dist
echo "--- SSS: Ejecutando build inicial de Vite... ---"
npm run build

# 2. Iniciar el proceso de 'watch' de Vite en segundo plano
echo "--- SSS: Iniciando Vite en modo 'watch' en segundo plano... ---"
npm run dev &

# 3. Iniciar Nginx en primer plano (este ser√° el proceso principal del contenedor)
echo "--- SSS: Iniciando Nginx en primer plano... ---"
nginx -g "daemon off;"

// --- ./frontend-react/index.html ---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitLab Review Task Dashboard</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// --- ./frontend-react/nginx.dev.conf ---

server {
    listen 80;
    server_name localhost;

    # La ra√≠z ahora apunta a la carpeta 'dist' donde Vite compila los archivos.
    root /app/dist;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    # El reverse proxy para el backend no cambia.
    location /api/ {
        proxy_pass http://backend:8001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

// --- ./frontend-react/package.json ---

{
    "name": "frontend-react",
    "private": true,
    "version": "0.0.0",
    "type": "module",
    "scripts": {
      "dev": "vite --host --port 3000",
      "build": "vite build",
      "preview": "vite preview"
    },
    "dependencies": {
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "axios": "^1.6.0",
      "react-router-dom": "^6.22.3"
    },
    "devDependencies": {
      "@types/react": "^18.2.15",
      "@types/react-dom": "^18.2.7",
      "@vitejs/plugin-react": "^4.0.3",
      "vite": "^4.4.5"
    }
  }

// --- ./frontend-react/src/App.css ---

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  margin: 0;
  background-color: #f8f9fa;
}

.container {
  padding: 1rem 2rem;
}

header h1 {
  border-bottom: 2px solid #dee2e6;
  padding-bottom: 0.5rem;
  color: #212529;
}

.dashboard-layout {
  display: flex;
  gap: 2rem;
}

.left-panel {
  flex: 1;
  max-width: 350px;
}

.right-panel {
  flex: 3;
}

.project-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.project-button {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ced4da;
  background-color: #fff;
  border-radius: 0.25rem;
  text-align: left;
  cursor: pointer;
  transition: background-color 0.2s ease, border-color 0.2s ease;
  font-size: 1rem;
}

.project-button:hover {
  background-color: #e9ecef;
}

.project-button.selected {
  background-color: #007bff;
  color: white;
  border-color: #007bff;
  font-weight: bold;
}

.error-message, .success-message {
    text-align: center;
    padding: 4rem;
}

/* ./frontend-react/src/components/TaskItem.css */
.task-item-container {
  border: 1px solid #dee2e6;
  border-radius: 4px;
  margin-bottom: 1rem;
  background-color: #fff;
}

.task-item-header {
  display: flex;
  align-items: center;
  padding: 0.75rem;
}

.task-link {
  margin-right: 1rem;
  font-weight: bold;
  white-space: nowrap;
  text-decoration: none;
}

.task-title {
  margin: 0;
  cursor: pointer;
  font-size: 1.1rem;
}

.task-item-details {
  padding: 0 1rem 1rem 1rem;
  border-top: 1px solid #e9ecef;
}

.task-meta {
  display: flex;
  gap: 1.5rem;
  font-size: 0.9rem;
  color: #6c757d;
}

.tabs-container {
  display: flex;
  gap: 0.5rem;
  margin-top: 1rem;
  border-bottom: none; /* Eliminamos el borde inferior */
  padding-bottom: 0.5rem;
}

.tab-button {
  width: auto;
  padding: 0.75rem 1rem;
  border: 1px solid #ced4da;
  background-color: #fff;
  border-radius: 0.25rem;
  text-align: left;
  cursor: pointer;
  transition: background-color 0.2s ease, border-color 0.2s ease;
  font-size: 1rem;
}

.tab-button:hover {
  background-color: #e9ecef;
}

.tab-button.active {
  background-color: #e9ecef; /* Color gris */
  color: #212529;
  border-color: #ced4da;
  font-weight: bold;
}

.status-message {
  padding: 2rem;
  text-align: center;
  font-size: 1.2rem;
  color: #6c757d;
}

.status-message.error {
  color: #dc3545;
  font-weight: bold;
}

.header-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1rem;
}

.sync-container {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.sync-button {
  padding: 0.75rem 1rem;
  border: 1px solid #28a745;
  background-color: #28a745;
  color: white;
  border-radius: 0.25rem;
  cursor: pointer;
  font-weight: bold;
  transition: background-color 0.2s ease;
}

.sync-button:hover {
  background-color: #218838;
}

.sync-button:disabled {
  background-color: #6c757d;
  border-color: #6c757d;
  cursor: not-allowed;
}

.sync-time {
  font-size: 0.9rem;
  color: #6c757d;
}

// --- ./frontend-react/src/App.jsx ---

// ./frontend-react/src/App.jsx
import React, { useState, useEffect } from 'react';
import { getActiveProjects, getAllTasksByLabel, forceSyncAll, getLastSyncTime, getSyncStatus } from './services/api';
import ProjectList from './components/ProjectList';
import TaskDetails from './components/TaskDetails';
import './App.css';

const TABS = {
  'Ejecuci√≥n': 'En Ejecucion',
  'Revisi√≥n': 'PARA REVISI√ìN',
  'Rev. Funcional': 'Revision Funcional',
};

function App() {
  const [projects, setProjects] = useState([]);
  const [tasks, setTasks] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [activeTab, setActiveTab] = useState(TABS['Revisi√≥n']);
  const [selectedProjectId, setSelectedProjectId] = useState(null);
  const [lastSyncTime, setLastSyncTime] = useState(null);
  const [isBackendSyncing, setIsBackendSyncing] = useState(false);

  const fetchData = async () => {
    setIsLoading(true);
    setError('');
    try {
      const [projectsData, tasksData, syncTimeData] = await Promise.all([
        getActiveProjects(activeTab),
        getAllTasksByLabel(activeTab),
        getLastSyncTime()
      ]);
      
      setProjects(projectsData);
      setTasks(tasksData);
      setLastSyncTime(syncTimeData.last_sync_time);
      
    } catch (err) {
      console.error("Error en fetchData:", err);
      setError(`Fallo al cargar los datos. Verifique la conexi√≥n con la API.`);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Hook para polling de estado
  useEffect(() => {
    const pollSyncStatus = async () => {
      try {
        const status = await getSyncStatus();
        const isCurrentlySyncing = status.is_syncing;
        if (isBackendSyncing && !isCurrentlySyncing) {
          fetchData();
        }
        setIsBackendSyncing(isCurrentlySyncing);
      } catch (pollError) {
        console.error("Error en el polling de estado de sincronizaci√≥n:", pollError);
        setIsBackendSyncing(false);
      }
    };
    pollSyncStatus();
    const intervalId = setInterval(pollSyncStatus, 3000);
    return () => clearInterval(intervalId);
  }, [isBackendSyncing]);

  // Hook para cargar datos cuando cambia la pesta√±a
  useEffect(() => {
    fetchData();
  }, [activeTab]);

  // SSS: CORRECCI√ìN DE UX FINAL
  // Este nuevo hook se ejecuta DESPU√âS de que los proyectos han sido actualizados
  useEffect(() => {
    if (projects && projects.length > 0) {
      setSelectedProjectId(projects[0].id); // Seleccionar siempre el primer proyecto
    } else {
      setSelectedProjectId(null); // Si no hay proyectos, deseleccionar
    }
  }, [projects]); // Dependencia: la lista de proyectos

  const handleForceSync = async () => {
    setIsBackendSyncing(true);
    setError('');
    try {
      await forceSyncAll();
    } catch (err) {
      setError("Fallo al iniciar la sincronizaci√≥n o ya hay una en curso.");
      setIsBackendSyncing(false);
    }
  };
  
  const handleSelectProject = (projectId) => {
    if (selectedProjectId === projectId) {
      setSelectedProjectId(null);
    } else {
      setSelectedProjectId(projectId);
    }
  };

  const filteredTasks = selectedProjectId
    ? tasks.filter(task => task.project_id === selectedProjectId)
    : []; // SSS: Si no hay proyecto seleccionado, no mostrar ninguna tarea inicialmente.
  
  const getCategoryName = () => {
      return Object.keys(TABS).find(key => TABS[key] === activeTab) || 'Desconocida';
  }

  const getProjectName = () => {
      // SSS: CORRECCI√ìN - Mostrar "Seleccione un proyecto" si no hay ninguno seleccionado.
      if (!selectedProjectId) return "Seleccione un proyecto";
      return projects.find(p => p.id === selectedProjectId)?.name || "Proyecto Desconocido";
  }

  const renderContent = () => {
    if (isLoading && !isBackendSyncing) {
      return <div className="status-message">Cargando datos...</div>;
    }
    if (error) {
      return <div className="status-message error">{error}</div>;
    }
    return (
      <main className="dashboard-layout">
        <aside className="left-panel">
          <ProjectList
            projects={projects}
            selectedProjectId={selectedProjectId}
            onSelectProject={handleSelectProject}
            disabled={isBackendSyncing}
          />
        </aside>
        <section className="right-panel">
          <TaskDetails
            tasks={filteredTasks}
            categoryName={`${getCategoryName()} en: ${getProjectName()}`}
            isLoading={isLoading || isBackendSyncing}
          />
        </section>
      </main>
    );
  };

  return (
    <div className="container">
      <header>
        <h1>üìà Dashboard de Tareas GitLab</h1>
        <div className="header-controls">
          <div className="tabs-container">
            {Object.entries(TABS).map(([displayName, canonicalName]) => (
              <button
                key={canonicalName}
                className={`tab-button ${activeTab === canonicalName ? 'active' : ''}`}
                onClick={() => setActiveTab(canonicalName)}
                disabled={isBackendSyncing}
              >
                {displayName}
              </button>
            ))}
          </div>
          <div className="sync-container">
            <button onClick={handleForceSync} disabled={isBackendSyncing} className="sync-button">
              {isBackendSyncing ? 'Sincronizando...' : 'Sincronizar Ahora'}
            </button>
            {lastSyncTime && (
              <span className="sync-time">
                √öltima Sinc: {new Date(lastSyncTime).toLocaleString()}
              </span>
            )}
          </div>
        </div>
      </header>
      {renderContent()}
    </div>
  );
}

export default App;

// --- ./frontend-react/src/components/Navbar.css ---

.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 2rem;
  background-color: #fff;
  border-bottom: 1px solid #dee2e6;
}
.navbar-brand {
  font-weight: bold;
  font-size: 1.25rem;
  text-decoration: none;
  color: #212529;
}
.navbar-links {
  display: flex;
  gap: 1.5rem;
}
.nav-link {
  text-decoration: none;
  color: #495057;
  font-size: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 3px solid transparent;
}
.nav-link.active {
  color: #007bff;
  border-bottom-color: #007bff;
}

// --- ./frontend-react/src/components/Navbar.jsx ---

import React from 'react';
import { NavLink } from 'react-router-dom';

const Navbar = () => (
  <nav className="navbar">
    <div className="navbar-brand">
      <NavLink to="/" className="navbar-item brand">üìñ Portal Unificado</NavLink>
    </div>
    <div className="navbar-menu">
      <NavLink to="/" className={({ isActive }) => (isActive ? 'navbar-item active' : 'navbar-item')}>Home</NavLink>
      <NavLink to="/tasks" className={({ isActive }) => (isActive ? 'navbar-item active' : 'navbar-item')}>Tareas</NavLink>
      <NavLink to="/documentation" className={({ isActive }) => (isActive ? 'navbar-item active' : 'navbar-item')}>Documentaci√≥n</NavLink>
      <NavLink to="/projects" className={({ isActive }) => (isActive ? 'navbar-item active' : 'navbar-item')}>Proyectos</NavLink>
    </div>
  </nav>
);

export default Navbar;

// --- ./frontend-react/src/components/PageTree.jsx ---

import React, { useState } from 'react';
import './PageTree.css';

const PageTreeNode = ({ node, onSelectPage }) => {
  const [isOpen, setIsOpen] = useState(true);
  const isFolder = node.type === 'folder';

  const handleToggle = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = () => {
    if (!isFolder) {
      onSelectPage({ slug: node.slug, title: node.title });
    }
  };

  return (
    <div className="tree-node">
      <div className={`node-label ${isFolder ? 'folder' : 'file'}`} onClick={isFolder ? handleToggle : handleSelect}>
        {isFolder && <span>{isOpen ? '‚ñº' : '‚ñ∫'} </span>}
        {node.title}
      </div>
      {isFolder && isOpen && (
        <div className="node-children">
          <PageTree nodes={node.children} onSelectPage={onSelectPage} />
        </div>
      )}
    </div>
  );
};

const PageTree = ({ nodes, onSelectPage }) => (
  <div>
    {nodes.map(node => (
      <PageTreeNode key={node.id} node={node} onSelectPage={onSelectPage} />
    ))}
  </div>
);

export default PageTree;

// --- ./frontend-react/src/components/ProjectList.jsx ---

import React from 'react';

const ProjectList = ({ projects, selectedProjectId, onSelectProject }) => {
  return (
    <div>
      <h3>Proyectos Activos</h3>
      <div className="project-list">
        {projects.map(project => (
          <button
            key={project.id}
            // SSS: La clase 'selected' ahora se basa en la prop 'selectedProjectId'
            className={`project-button ${project.id === selectedProjectId ? 'selected' : ''}`}
            // SSS: El onClick ahora llama a la funci√≥n pasada desde App.jsx
            onClick={() => onSelectProject(project.id)}
          >
            {project.name} ({project.review_task_count})
          </button>
        ))}
      </div>
    </div>
  );
};

export default ProjectList;

// --- ./frontend-react/src/components/TaskDetails.jsx ---

import React from 'react';
import TaskItem from './TaskItem';

const TaskDetails = ({ tasks, isLoading, categoryName }) => {
  if (isLoading) {
    return <div>Cargando tareas...</div>;
  }

  if (!tasks || tasks.length === 0) {
    return <div>No hay tareas en la selecci√≥n actual.</div>;
  }

  return (
    <div>
      <h3>Tareas para: {categoryName}</h3>
      {tasks.map(task => (
        <TaskItem key={task.url} task={task} />
      ))}
    </div>
  );
};

export default TaskDetails;

// --- ./frontend-react/src/components/TaskItem.css ---

.task-extended-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    font-size: 0.9rem;
    color: #6c757d;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px dashed #ced4da;
  }
  
  .task-labels {
    margin-top: 0.75rem;
  }
  
  .task-label {
    display: inline-block;
    padding: 0.25em 0.6em;
    font-size: 75%;
    font-weight: 700;
    line-height: 1;
    text-align: center;
    white-space: nowrap;
    vertical-align: baseline;
    border-radius: 0.25rem;
    background-color: #e9ecef;
    color: #495057;
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
  }

// --- ./frontend-react/src/components/TaskItem.jsx ---

import React, { useState } from 'react';
import './TaskItem.css';

/**
 * Sanitiza un texto en Markdown eliminando la sintaxis de im√°genes.
 * @param {string | null} text El texto a limpiar.
 * @returns {string} El texto limpio.
 */
const sanitizeMarkdown = (text) => {
  if (!text) return 'Sin descripci√≥n.';
  // Expresi√≥n regular para encontrar y reemplazar ![alt text](url)
  return text.replace(/!\[.*?\]\(.*?\)/g, '[Imagen Omitida]');
};

const TaskItem = ({ task }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div className="task-item-container">
      <div className="task-item-header">
        <a href={task.url} target="_blank" rel="noopener noreferrer" className="task-link">
          [LINK]
        </a>
        <h5 className="task-title" onClick={() => setIsExpanded(!isExpanded)}>
          {/* SSS: Se a√±ade el nombre del proyecto para el contexto */}
          <strong>[{task.project_name}]</strong> {task.title}
        </h5>
      </div>
      {isExpanded && (
        <div className="task-item-details">
          <p>{sanitizeMarkdown(task.description)}</p>
          <hr />
          <div className="task-meta">
            <span><strong>Autor:</strong> {task.author}</span>
            {task.assignee && <span><strong>Asignado a:</strong> {task.assignee}</span>}
            {task.milestone && <span><strong>Milestone:</strong> {task.milestone}</span>}
          </div>
          {/* SSS: NUEVA SECCI√ìN DE DATOS EXTENDIDOS */}
          <div className="task-extended-meta">
            <span><strong>Creado:</strong> {new Date(task.created_at).toLocaleDateString()}</span>
            {task.time_stats.human_total_time_spent && <span><strong>Tiempo Invertido:</strong> {task.time_stats.human_total_time_spent}</span>}
            {task.time_stats.human_time_estimate && <span><strong>Tiempo Estimado:</strong> {task.time_stats.human_time_estimate}</span>}
          </div>
          {task.labels && task.labels.length > 0 && (
            <div className="task-labels">
              {task.labels.map(label => (
                <span key={label} className="task-label">{label}</span>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default TaskItem;

// --- ./frontend-react/src/main.jsx ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './App.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// --- ./frontend-react/src/pages/DocumentationPage.jsx ---

import React from 'react';
export default function DocumentationPage() {
  return <div><h2>Portal de Documentaci√≥n (en construcci√≥n)</h2></div>;
}

// --- ./frontend-react/src/pages/HomePage.jsx ---

import React from 'react';
export default function HomePage() {
  return <div><h2>Bienvenido al Portal Unificado</h2><p>Use la navegaci√≥n para explorar.</p></div>;
}


// --- ./frontend-react/src/pages/ProjectsPage.jsx ---

import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ProjectsPage() {
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [newProjectId, setNewProjectId] = useState('');
  const [newProjectName, setNewProjectName] = useState('');
  const [formError, setFormError] = useState('');

  const fetchProjects = () => { /* ... (c√≥digo de la respuesta anterior, es correcto) ... */ };
  useEffect(() => { fetchProjects(); }, []);
  const handleAddProject = (e) => { /* ... (c√≥digo de la respuesta anterior, es correcto) ... */ };

  return (
    <div>
      <h2>Gesti√≥n de Proyectos Monitoreados</h2>
      <div className="project-management-container">
        <div className="add-project-form">
          <h3>A√±adir Nuevo Proyecto</h3>
          <form onSubmit={handleAddProject}>
            <input type="number" value={newProjectId} onChange={(e) => setNewProjectId(e.target.value)} placeholder="ID del Proyecto" required />
            <input type="text" value={newProjectName} onChange={(e) => setNewProjectName(e.target.value)} placeholder="Nombre del Proyecto" required />
            <button type="submit">A√±adir Proyecto</button>
            {formError && <p className="error-message">{formError}</p>}
          </form>
        </div>
        <div className="project-list">
          <h3>Proyectos Actuales</h3>
          {loading && <p>Cargando...</p>}
          {error && <p className="error-message">{error}</p>}
          <table>
            <thead><tr><th>ID</th><th>Nombre</th></tr></thead>
            <tbody>{projects.map(p => (<tr key={p.project_id}><td>{p.project_id}</td><td>{p.project_name}</td></tr>))}</tbody>
          </table>
        </div>
      </div>
    </div>
  );
}
export default ProjectsPage;

// --- ./frontend-react/src/pages/TaskDashboardPage.jsx ---

// ./frontend-react/src/App.jsx
import React, { useState, useEffect } from 'react';
import { getActiveProjects, getAllTasksByLabel, forceSyncAll, getLastSyncTime, getSyncStatus } from './services/api';
import ProjectList from './components/ProjectList';
import TaskDetails from './components/TaskDetails';
import './App.css';

const TABS = {
  'Ejecuci√≥n': 'En Ejecucion',
  'Revisi√≥n': 'PARA REVISI√ìN',
  'Rev. Funcional': 'Revision Funcional',
};

function TaskDashboardPage() {
  const [projects, setProjects] = useState([]);
  const [tasks, setTasks] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [activeTab, setActiveTab] = useState(TABS['Revisi√≥n']);
  const [selectedProjectId, setSelectedProjectId] = useState(null);
  const [lastSyncTime, setLastSyncTime] = useState(null);
  const [isBackendSyncing, setIsBackendSyncing] = useState(false);

  const fetchData = async () => {
    setIsLoading(true);
    setError('');
    try {
      const [projectsData, tasksData, syncTimeData] = await Promise.all([
        getActiveProjects(activeTab),
        getAllTasksByLabel(activeTab),
        getLastSyncTime()
      ]);
      
      setProjects(projectsData);
      setTasks(tasksData);
      setLastSyncTime(syncTimeData.last_sync_time);
      
    } catch (err) {
      console.error("Error en fetchData:", err);
      setError(`Fallo al cargar los datos. Verifique la conexi√≥n con la API.`);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Hook para polling de estado
  useEffect(() => {
    const pollSyncStatus = async () => {
      try {
        const status = await getSyncStatus();
        const isCurrentlySyncing = status.is_syncing;
        if (isBackendSyncing && !isCurrentlySyncing) {
          fetchData();
        }
        setIsBackendSyncing(isCurrentlySyncing);
      } catch (pollError) {
        console.error("Error en el polling de estado de sincronizaci√≥n:", pollError);
        setIsBackendSyncing(false);
      }
    };
    pollSyncStatus();
    const intervalId = setInterval(pollSyncStatus, 3000);
    return () => clearInterval(intervalId);
  }, [isBackendSyncing]);

  // Hook para cargar datos cuando cambia la pesta√±a
  useEffect(() => {
    fetchData();
  }, [activeTab]);

  // SSS: CORRECCI√ìN DE UX FINAL
  // Este nuevo hook se ejecuta DESPU√âS de que los proyectos han sido actualizados
  useEffect(() => {
    if (projects && projects.length > 0) {
      setSelectedProjectId(projects[0].id); // Seleccionar siempre el primer proyecto
    } else {
      setSelectedProjectId(null); // Si no hay proyectos, deseleccionar
    }
  }, [projects]); // Dependencia: la lista de proyectos

  const handleForceSync = async () => {
    setIsBackendSyncing(true);
    setError('');
    try {
      await forceSyncAll();
    } catch (err) {
      setError("Fallo al iniciar la sincronizaci√≥n o ya hay una en curso.");
      setIsBackendSyncing(false);
    }
  };
  
  const handleSelectProject = (projectId) => {
    if (selectedProjectId === projectId) {
      setSelectedProjectId(null);
    } else {
      setSelectedProjectId(projectId);
    }
  };

  const filteredTasks = selectedProjectId
    ? tasks.filter(task => task.project_id === selectedProjectId)
    : []; // SSS: Si no hay proyecto seleccionado, no mostrar ninguna tarea inicialmente.
  
  const getCategoryName = () => {
      return Object.keys(TABS).find(key => TABS[key] === activeTab) || 'Desconocida';
  }

  const getProjectName = () => {
      // SSS: CORRECCI√ìN - Mostrar "Seleccione un proyecto" si no hay ninguno seleccionado.
      if (!selectedProjectId) return "Seleccione un proyecto";
      return projects.find(p => p.id === selectedProjectId)?.name || "Proyecto Desconocido";
  }

  const renderContent = () => {
    if (isLoading && !isBackendSyncing) {
      return <div className="status-message">Cargando datos...</div>;
    }
    if (error) {
      return <div className="status-message error">{error}</div>;
    }
    return (
      <main className="dashboard-layout">
        <aside className="left-panel">
          <ProjectList
            projects={projects}
            selectedProjectId={selectedProjectId}
            onSelectProject={handleSelectProject}
            disabled={isBackendSyncing}
          />
        </aside>
        <section className="right-panel">
          <TaskDetails
            tasks={filteredTasks}
            categoryName={`${getCategoryName()} en: ${getProjectName()}`}
            isLoading={isLoading || isBackendSyncing}
          />
        </section>
      </main>
    );
  };

  return (
    <div className="container">
      <header>
        <h1>üìà Dashboard de Tareas GitLab</h1>
        <div className="header-controls">
          <div className="tabs-container">
            {Object.entries(TABS).map(([displayName, canonicalName]) => (
              <button
                key={canonicalName}
                className={`tab-button ${activeTab === canonicalName ? 'active' : ''}`}
                onClick={() => setActiveTab(canonicalName)}
                disabled={isBackendSyncing}
              >
                {displayName}
              </button>
            ))}
          </div>
          <div className="sync-container">
            <button onClick={handleForceSync} disabled={isBackendSyncing} className="sync-button">
              {isBackendSyncing ? 'Sincronizando...' : 'Sincronizar Ahora'}
            </button>
            {lastSyncTime && (
              <span className="sync-time">
                √öltima Sinc: {new Date(lastSyncTime).toLocaleString()}
              </span>
            )}
          </div>
        </div>
      </header>
      {renderContent()}
    </div>
  );
}

export default TaskDashboardPage;

// --- ./frontend-react/src/pages/TasksPage.jsx ---

import React from 'react';
export default function TasksPage() {
  return <div><h2>P√°gina de Tareas (en construcci√≥n)</h2></div>;
}

// --- ./frontend-react/src/services/api.js ---

import axios from 'axios';

const apiClient = axios.create({
  baseURL: '/tareas/api',
});

/**
 * Obtiene la lista de proyectos activos para una etiqueta de estado espec√≠fica.
 * @param {string} label El nombre can√≥nico de la etiqueta de estado.
 * @returns {Promise<Array>} Una promesa que resuelve a un array de proyectos.
 */
export const getActiveProjects = async (label) => {
  if (!label) return [];
  try {
    // SSS: CORRECCI√ìN CR√çTICA Y FINAL
    // La petici√≥n DEBE incluir el objeto de configuraci√≥n { params: ... }
    // para que axios construya la URL correctamente (ej. ...?label=En+Ejecucion)
    const response = await apiClient.get('/projects/active_from_db', { params: { label } });
    return response.data;
  } catch (error) {
    console.error("Error fetching active projects:", error);
    throw error;
  }
};

/**
 * Obtiene las tareas para un ID de proyecto y una etiqueta de estado espec√≠ficos.
 * @param {number} projectId El ID del proyecto.
 * @param {string} label El nombre can√≥nico de la etiqueta de estado.
 * @returns {Promise<Array>} Una promesa que resuelve a un array de tareas.
 */
export const getTasksForProject = async (projectId, label) => {
  if (!projectId || !label) return [];
  try {
    const response = await apiClient.get(`/projects/${projectId}/tasks_from_db`, { params: { label } });
    return response.data;
  } catch (error) {
    console.error(`Error fetching tasks for project ${projectId} and label ${label}:`, error);
    throw error;
  }
};

/**
 * Obtiene TODAS las tareas para una etiqueta de estado espec√≠fica, de todos los proyectos.
 * @param {string} label El nombre can√≥nico de la etiqueta de estado.
 * @returns {Promise<Array>} Una promesa que resuelve a un array de tareas enriquecidas.
 */
export const getAllTasksByLabel = async (label) => {
  if (!label) return [];
  try {
    const response = await apiClient.get('/tasks/all_by_label', { params: { label } });
    return response.data;
  } catch (error) {
    console.error(`Error fetching all tasks for label ${label}:`, error);
    throw error;
  }
};

export const forceSyncAll = async () => {
  try {
    const response = await apiClient.post('/sync/all');
    return response.data;
  } catch (error) {
    console.error("Error forcing sync:", error);
    throw error;
  }
};

export const getLastSyncTime = async () => {
  try {
    const response = await apiClient.get('/sync/last_time');
    return response.data;
  } catch (error) {
    console.error("Error fetching last sync time:", error);
    throw error;
  }
};

export const getSyncStatus = async () => {
  try {
    const response = await apiClient.get('/sync/status');
    return response.data;
  } catch (error) {
    console.error("Error fetching sync status:", error);
    return { is_syncing: false };
  }
};

// --- ./frontend-react/supervisord.conf ---

; /frontend-react/supervisord.conf

[supervisord]
nodaemon=true

[program:nginx]
command=/usr/sbin/nginx -g "daemon off;"
autostart=true
autorestart=true
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0

[program:vite]
command=npm run dev
directory=/app
autostart=true
autorestart=true
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0

// --- ./frontend-react/vite.config.js ---

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  // SSS: Directiva CR√çTICA para el despliegue en subdirectorio.
  // Esto asegura que todas las rutas de assets (JS, CSS, etc.) se generen
  // con el prefijo /tareas/.
  base: '/tareas/',

  server: {
    host: '0.0.0.0', 
    port: 3000,
    hmr: {
      clientPort: 8503,
      protocol: 'ws',
    },
  },
})

// --- ./frontend/Dockerfile ---

# /frontend/Dockerfile
FROM python:3.11-slim-bookworm

WORKDIR /app

# Copy and install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the application code and static assets
COPY . .

# Expose the default Streamlit port
EXPOSE 8501

# The command to run the Streamlit application
CMD ["streamlit", "run", "app.py", "--server.port=8501", "--server.address=0.0.0.0"]

// --- ./frontend/app.py ---

# app.py - Frontend Streamlit (Dise√±o Final v14 - Ajuste Fino)
import datetime

import pandas as pd
import requests
import streamlit as st

# --- Configuration ---
API_BASE_URL = "http://backend:8001"
st.set_page_config(
    page_title="Task Dashboard",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="auto",
)


# --- Functions ---
def load_css(file_name: str):
    """
    Loads a local CSS file into the Streamlit application.

    Args:
        file_name (str): The path to the CSS file.
    """
    with open(file_name) as f:
        st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)


# Load custom CSS
load_css("static/style.css")


@st.cache_data(ttl=300)
def get_projects_data():
    try:
        response = requests.get(f"{API_BASE_URL}/projects/")
        response.raise_for_status()
        projects = response.json()
        if not projects:
            return None
        return pd.DataFrame(projects)
    except requests.exceptions.RequestException:
        return None


def show_task_details(column, project_id, project_name):
    column.header(f"Detalles para: {project_name}")
    with st.spinner("Cargando tareas..."):
        try:
            response = requests.get(
                f"{API_BASE_URL}/projects/{project_id}/review_tasks/"
            )
            response.raise_for_status()
            tasks = response.json()
            if not tasks:
                column.success(
                    "‚úÖ Congratulations! There is not task to check in this project"
                )
                return

            for task in tasks:
                with st.container(border=True):
                    c1, c2 = st.columns([1, 20])

                    with c1:
                        st.markdown(
                            f"<a href='{task['url']}' target='_blank' style='white-space: nowrap;'>[LINK]</a>",
                            unsafe_allow_html=True,
                        )

                    with c2:
                        # Usar markdown con h5 para un tama√±o de fuente menor
                        st.markdown(f"<h5>{task['title']}</h5>", unsafe_allow_html=True)

                    with st.expander("Ver Descripci√≥n y Detalles"):
                        st.markdown(
                            task["description"]
                            if task["description"]
                            else "_Sin descripci√≥n._"
                        )
                        st.markdown("---")
                        st.caption(f"‚úçÔ∏è **Autor:** {task['author']}")
                        if task.get("assignee"):
                            st.caption(f"üë§ **Asignado a:** {task['assignee']}")
                        if task.get("milestone"):
                            st.caption(f"üéØ **Milestone:** {task['milestone']}")

        except requests.exceptions.RequestException:
            column.error(f"‚ùå None task could be taken {project_name}.")


# --- Main flow of the app ---
st.title("üìà Dashboard of Task to check")
st.divider()
projects_df = get_projects_data()

if projects_df is None:
    st.error(
        "‚ùå There is not project configured and the connection with backend could not be established"
    )
else:
    projects_df.sort_values(by="review_task_count", ascending=False, inplace=True)
    active_projects_df = projects_df[projects_df["review_task_count"] > 0].copy()

    left_col, right_col = st.columns([1, 3])

    if "selected_project_id" not in st.session_state and not active_projects_df.empty:
        default_project = active_projects_df.iloc[0]
        st.session_state["selected_project_id"] = default_project["id"]
        st.session_state["selected_project_name"] = default_project["name"]

    with left_col:
        tod = datetime.datetime.now()
        st.subheader("Proyectos Activos")
        # st.subheader(str(tod.day()) + "/" + str(tod.month()) + "/" + str(tod.year()))
        st.divider()

        for index, row in active_projects_df.iterrows():
            project_id, project_name, task_count = (
                row["id"],
                row["name"],
                row["review_task_count"],
            )
            is_selected = st.session_state.get("selected_project_id") == project_id
            button_type = "primary" if is_selected else "secondary"

            button_label = f"{project_name} ({task_count})"
            if st.button(
                button_label,
                key=f"btn_{project_id}",
                use_container_width=True,
                type=button_type,
            ):
                st.session_state["selected_project_id"] = project_id
                st.session_state["selected_project_name"] = project_name
                st.rerun()

    with right_col:
        if not active_projects_df.empty and "selected_project_id" in st.session_state:
            show_task_details(
                right_col,
                st.session_state["selected_project_id"],
                st.session_state["selected_project_name"],
            )
        elif active_projects_df.empty:
            right_col.success(
                "üéâ ¬°Excelente trabajo! No hay tareas en revisi√≥n en ning√∫n proyecto."
            )
        else:
            right_col.info(
                "‚¨ÖÔ∏è Selecciona un proyecto del men√∫ para ver los detalles de sus tareas."
            )


// --- ./frontend/pages/2_Documentation_Portal.py ---

<<<<<<< HEAD
from urllib.parse import quote

import requests
import streamlit as st

# --- Configuraci√≥n ---
API_BASE_URL = "http://backend:8001"
st.set_page_config(page_title="Portal de Documentaci√≥n", page_icon="üìñ", layout="wide")
# El tema se configura globalmente

# --- CSS para estilizar la navegaci√≥n ---
st.markdown(
    """
<style>
    /* Estilo para los contenedores de los botones para poder ocultarlos */
    .stButton > button {
        display: none;
    }
    .nav-link {
        cursor: pointer; display: block; padding: 0.3em 0.5em; border-radius: 0.25rem;
        transition: background-color 0.2s ease-in-out; color: #31333F; text-decoration: none;
    }
    .nav-link:hover {
        background-color: #F0F2F6;
    }
    .nav-link-selected {
        background-color: #0068C9 !important; color: white !important; font-weight: bold;
    }
    [data-testid="stExpander"] div[role="button"] + div {
        padding-left: 20px;
    }
</style>
""",
    unsafe_allow_html=True,
)


# --- Funciones de la API (sin cambios) ---
@st.cache_data(ttl=600)
=======
# frontend/pages/2_Documentation_Portal.py
import streamlit as st
import requests

# --- Configuraci√≥n ---
API_BASE_URL = "http://backend:8001"
st.set_page_config(page_title="Portal de Documentaci√≥n", layout="wide")

st.title("üìñ Portal de Documentaci√≥n")
st.divider()

# --- Funciones de la API ---
@st.cache_data(ttl=600) # Cache para 10 minutos
>>>>>>> 934b995f50798a832f6fad9e0f26cfd2865870ba
def get_wiki_projects():
    try:
        response = requests.get(f"{API_BASE_URL}/wiki/projects")
        response.raise_for_status()
        return response.json()
<<<<<<< HEAD
    except:
        return None


@st.cache_data(ttl=300)
def get_wiki_pages_tree(project_id):
    try:
        response = requests.get(f"{API_BASE_URL}/wiki/projects/{project_id}/pages/tree")
        response.raise_for_status()
        return response.json()
    except:
        return []


@st.cache_data(ttl=60)
def get_page_content(project_id, slug):
    try:
        encoded_slug = quote(slug, safe="")
        response = requests.get(
            f"{API_BASE_URL}/wiki/projects/{project_id}/pages/{encoded_slug}"
        )
        response.raise_for_status()
        return response.json()
    except:
        return {"content": "Error al cargar el contenido.", "title": "Error"}


@st.cache_data(ttl=60)
def get_pdf_data(project_id, slug):
    """Funci√≥n dedicada para obtener los bytes del PDF, con cache."""
    try:
        encoded_slug = quote(slug, safe="")
        pdf_url = (
            f"{API_BASE_URL}/wiki/projects/{project_id}/generate_pdf/{encoded_slug}"
        )
        response = requests.get(pdf_url, verify=False)
        response.raise_for_status()
        return response.content
    except Exception:
        return None


# --- L√≥gica de la UI (Refactorizada) ---
def update_selected_page(slug):
    """Callback para actualizar el estado de la sesi√≥n."""
    st.session_state.selected_page_slug = slug


def render_tree_navigation(nodes, selected_slug):
    """Renderiza la navegaci√≥n de √°rbol usando st.expander y st.button para m√°xima fiabilidad."""
    for node in nodes:
        if node["type"] == "folder":
            with st.expander(f"üìÅ {node['title']}", expanded=True):
                render_tree_navigation(node["children"], selected_slug)
        else:  # 'file'
            is_selected = node["slug"] == selected_slug
            css_class = "nav-link-selected" if is_selected else "nav-link"
            st.markdown(
                f'<div class="{css_class}" onclick="document.getElementById(\'btn-{node["slug"]}\').click()">{node["title"]}</div>',
                unsafe_allow_html=True,
            )
            st.button(
                "select",
                key=f"btn-{node['slug']}",
                on_click=update_selected_page,
                args=(node["slug"],),
            )


def find_first_file(nodes):
    """Encuentra recursivamente el slug del primer archivo en el √°rbol."""
    for node in nodes:
        if node["type"] == "file":
            return node["slug"]
        if node["type"] == "folder":
            first_in_folder = find_first_file(node["children"])
            if first_in_folder:
                return first_in_folder
    return None


# --- Flujo Principal de la P√°gina ---
st.title("üìñ Portal de Documentaci√≥n")
st.divider()

projects = get_wiki_projects()

if not projects:
    st.error("No se encontraron proyectos con Wiki activa.")
else:
    project_names = {p["name"]: p["id"] for p in projects}

    # Manejo del estado de la sesi√≥n
    if "selected_project_id" not in st.session_state:
        st.session_state.selected_project_id = list(project_names.values())[0]

    def on_project_change():
        st.session_state.selected_project_id = project_names[
            st.session_state.project_selector
        ]
        # Borramos el slug seleccionado para que la nueva l√≥gica lo determine
        if "selected_page_slug" in st.session_state:
            del st.session_state["selected_page_slug"]

    project_ids = list(project_names.values())
    try:
        current_project_index = project_ids.index(st.session_state.selected_project_id)
    except ValueError:
        current_project_index = 0

    st.selectbox(
        "Seleccione un Proyecto:",
        options=project_names.keys(),
        key="project_selector",
        index=current_project_index,
        on_change=on_project_change,
    )

    project_id = st.session_state.selected_project_id
    pages_tree = get_wiki_pages_tree(project_id)

    if not pages_tree:
        st.warning("Esta wiki est√° vac√≠a o no se pudieron cargar sus p√°ginas.")
    else:
        left_col, right_col = st.columns([1, 3])

        # --- SSS: L√≥gica de Selecci√≥n Inteligente de P√°gina por Defecto ---
        if "selected_page_slug" not in st.session_state:
            home_node = next(
                (
                    node
                    for node in pages_tree
                    if node["type"] == "file" and node["slug"] == "home"
                ),
                None,
            )
            if home_node:
                st.session_state.selected_page_slug = "home"
            else:
                st.session_state.selected_page_slug = find_first_file(pages_tree) or ""

        slug_to_load = st.session_state.get("selected_page_slug")

        with left_col:
            st.subheader("P√°ginas")
            render_tree_navigation(pages_tree, slug_to_load)

        with right_col:
            if not slug_to_load:
                st.info("Seleccione una p√°gina de la izquierda para ver su contenido.")
            else:
                content_data = get_page_content(project_id, slug_to_load)

                st.header(content_data.get("title", slug_to_load))

                # Descarga de PDF
                try:
                    response = requests.get(
                        f"{API_BASE_URL}/wiki/projects/{project_id}/generate_pdf/{quote(slug_to_load, safe='')}",
                        verify=False,
                    )
                    response.raise_for_status()
                    st.download_button(
                        label="‚¨áÔ∏è Descargar como PDF",
                        data=response.content,
                        file_name=f"{slug_to_load.split('/')[-1]}.pdf",
                        mime="application/pdf",
                    )
                except requests.exceptions.HTTPError as e:
                    try:
                        error_detail = e.response.json().get("detail", e.response.text)
                    except:
                        error_detail = e.response.text
                    st.error(f"No se pudo generar el PDF: {error_detail}")
                except Exception as e:
                    st.error(f"Error de conexi√≥n al generar PDF: {e}")

                st.divider()
                st.markdown(
                    content_data.get("content", "*No se encontr√≥ contenido.*"),
                    unsafe_allow_html=True,
                )
=======
    except requests.RequestException:
        return None

@st.cache_data(ttl=300) # Cache para 5 minutos
def get_wiki_pages(project_id):
    try:
        response = requests.get(f"{API_BASE_URL}/wiki/projects/{project_id}/pages")
        response.raise_for_status()
        return response.json()
    except requests.RequestException:
        return []

@st.cache_data(ttl=60) # Cache para 1 minuto
def get_page_content(project_id, slug):
    try:
        response = requests.get(f"{API_BASE_URL}/wiki/projects/{project_id}/pages/{slug}")
        response.raise_for_status()
        return response.json()
    except requests.RequestException:
        return {"content": "Error al cargar el contenido.", "title": "Error"}

# --- Interfaz de Usuario ---
projects = get_wiki_projects()

if not projects:
    st.error("No se pudieron cargar los proyectos desde el backend.")
else:
    project_names = {p['name']: p['id'] for p in projects}
    selected_project_name = st.selectbox("Seleccione un Proyecto:", options=project_names.keys())
    
    if selected_project_name:
        project_id = project_names[selected_project_name]
        
        with st.spinner(f"Cargando p√°ginas de la wiki para {selected_project_name}..."):
            pages = get_wiki_pages(project_id)

        if not pages:
            st.warning("Este proyecto no tiene p√°ginas de wiki o no se pudieron cargar.")
        else:
            left_col, right_col = st.columns([1, 3])
            
            with left_col:
                st.subheader("P√°ginas")
                page_slugs = {p['title']: p['slug'] for p in pages}
                
                # Usar st.session_state para mantener la p√°gina seleccionada
                if 'selected_page_slug' not in st.session_state:
                    st.session_state.selected_page_slug = pages[0]['slug']

                for title, slug in page_slugs.items():
                    if st.button(title, key=slug, use_container_width=True):
                        st.session_state.selected_page_slug = slug
                        # No es necesario st.rerun() si la l√≥gica de renderizado est√° debajo
            
            with right_col:
                if 'selected_page_slug' in st.session_state:
                    slug = st.session_state.selected_page_slug
                    with st.spinner(f"Cargando contenido de '{slug}'..."):
                        content_data = get_page_content(project_id, slug)

                    st.header(content_data['title'])
                    
                    # Enlace de descarga de PDF
                    st.download_button(
                        label="‚¨áÔ∏è Descargar como PDF",
                        data=requests.get(f"{API_BASE_URL}/wiki/projects/{project_id}/generate_pdf/{slug}").content,
                        file_name=f"{slug}.pdf",
                        mime="application/pdf",
                    )
                    
                    st.divider()
                    st.markdown(content_data['content'], unsafe_allow_html=True)
>>>>>>> 934b995f50798a832f6fad9e0f26cfd2865870ba


// --- ./frontend/requirements.txt ---

streamlit
requests
pandas
altair


// --- ./frontend/static/style.css ---

/* Hide unwanted Streamlit elements */
#MainMenu {visibility: hidden;}
footer {visibility: hidden;}
header {visibility: hidden;}

/* Main container */
.main .block-container {
    padding-top: 1rem;
    padding-bottom: 1rem;
    padding-left: 1rem;
    padding-right: 1rem;
}

/* Sticky sidebar menu */
div[data-testid="stHorizontalBlock"] > div:nth-child(1) > div {
    position: sticky;
    top: 2.5rem;
    background-color: #0E1117;
    z-index: 100;
}

/* Menu button style */
.stButton button {
    background-color: transparent;
    border: 1px solid #333;
    text-align: left;
    font-weight: normal;
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    transition: background-color 0.2s ease-in-out;
    margin-bottom: 0.5rem;
    display: flex;
    justify-content: space-between;
}
.stButton button:hover {
    background-color: #2a2a2a;
    border-color: #444;
}
.stButton button:focus {
    box-shadow: none !important;
}
.stButton button[kind="primary"] {
    background-color: #27ae60;
    border-color: #27ae60;
    font-weight: bold;
    color: white;
}

/* Task title (h5) */
div[data-testid="stVerticalBlock"] h5 {
    margin: 0;
    padding-top: 0.1rem; /* Fine vertical alignment */
    font-weight: 500;
    font-size: 1.1rem; /* Reduced font size */
    color: #FAFAFA;
}

/* Style for the expander to remove its own box */
[data-testid="stExpander"] {
    border: none !important;
    background-color: transparent !important;
    padding: 0 !important;
    margin: 0 !important;
}
[data-testid="stExpander"] summary {
    padding-left: 0;
    font-size: 0.9em;
    color: #aaa;
}

// --- ./nginx/Dockerfile ---

# /nginx/Dockerfile
# SSS v4.2.0 - Dockerfile para el servicio de Reverse Proxy Nginx

FROM nginx:1.25-alpine

# Eliminar la configuraci√≥n por defecto
RUN rm /etc/nginx/conf.d/default.conf

# Copiar nuestra configuraci√≥n personalizada
COPY nginx.conf /etc/nginx/conf.d/default.conf

// --- ./nginx/nginx.conf ---

server {
    listen 80;
    server_name localhost;

    location /tareas/api/ {
        rewrite ^/tareas(/.*)$ $1 break;
        proxy_pass http://backend:8001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /tareas/ {
        proxy_pass http://frontend-react:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}